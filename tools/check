#!/usr/bin/env bash

# Careful! `set -e` doesn't do everything you'd think it does. In
# fact, we don't get its benefit in any of the `run_foo` functions.
#
# This is because it has an effect only when it can exit the whole shell.
# (Its full name is `set -o errexit`, and it means "exit" literally.)  See:
#   https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin
#
# When one test suite fails, we want to go on to run the other suites, so
# we use `||` to prevent the whole script from exiting there, and that
# defeats `set -e`.
#
# For now our workaround is to put `|| return` in the `run_foo` just
# after each nontrivial command that isn't the final command in the
# function.
set -euo pipefail


## CLI PARSING

default_suites=(analyze test drift)
extra_suites=(
)

usage() {
    cat >&2 <<EOF
usage: tools/check [SUITE]...

Run our tests.

By default, run ${#default_suites[@]} suite(s):
  ${default_suites[*]}
and skip ${#extra_suites[@]} suite(s):
  ${extra_suites[*]}
EOF
    exit 2
}

opt_suites=()
while (( $# )); do
    case "$1" in
        analyze|test|drift)
            opt_suites+=("$1"); shift;;
        *) usage;;
    esac
done

if (( ! "${#opt_suites[@]}" )); then
    opt_suites=( "${default_suites[@]}" )
fi


## EXECUTION

rootdir=$(git rev-parse --show-toplevel)
cd "$rootdir"

. tools/lib/git.sh

# usage: check_no_changes CHANGE_DESCRIPTION [GIT_PATHSPECS...]
#
# Check that there were no changes to files matching GIT_PATHSPECS.
# Any changes get cleaned up but cause failure.
#
# This is useful for suites that check that some generated files
# in the tree are up to date.  Such a suite might regenerate the
# files, then call `check_no_changes` on the outputs to check that
# they match what was already in the tree.  Typically it also calls
# `check_no_uncommitted_or_untracked` on the same output paths
# before regenerating, to avoid clobbering any existing changes.
#
# A Git pathspec (as in GIT_PATHSPECS) is a filename, directory,
# or other pattern describing a subset of paths in the Git tree or worktree,
# to be passed as positional arguments to `git diff`, `git clean`, and
# many other Git commands.  For docs, see `git help glossary` under "pathspec".
#
# The CHANGE_DESCRIPTION is used in the error message on failure.
check_no_changes() {
    local change_description="$1"; shift

    if git diff --quiet -- "$@" \
            && no_untracked_files "$@"; then
        return
    fi

    echo >&2 "Error: there were ${change_description}:"
    git_status_short "$@"
    git checkout HEAD -- "$@"
    git clean -fd --quiet -- "$@"
    return 1
}

run_analyze() {
    flutter analyze
}

run_test() {
    flutter test
}

run_drift() {
    local schema_dir=test/model/schemas/

    check_no_uncommitted_or_untracked "${schema_dir}" \
    || return

    dart run drift_dev schema dump \
        lib/model/database.dart "${schema_dir}" \
    || return
    dart run drift_dev schema generate --data-classes --companions \
        "${schema_dir}" "${schema_dir}" \
    || return

    check_no_changes "schema updates" "${schema_dir}"
}

failed=()
for suite in "${opt_suites[@]}"; do
    echo "Running $suite..."
    case "$suite" in
        analyze)      run_analyze ;;
        test)         run_test ;;
        drift)        run_drift ;;
        *)            echo >&2 "Internal error: unknown suite $suite" ;;
    esac || failed+=( "$suite" )
done

if (( ${#failed[@]} )); then
    cat >&2 <<EOF

FAILED: ${failed[*]}

To rerun the suites that failed, run:
  $ tools/check ${failed[*]}
EOF
    exit 1
fi

echo "Passed!"
