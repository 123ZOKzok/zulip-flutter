#!/usr/bin/env bash

# Careful! `set -e` doesn't do everything you'd think it does. In
# fact, we don't get its benefit in any of the `run_foo` functions.
#
# This is because it has an effect only when it can exit the whole shell.
# (Its full name is `set -o errexit`, and it means "exit" literally.)  See:
#   https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin
#
# When one test suite fails, we want to go on to run the other suites, so
# we use `||` to prevent the whole script from exiting there, and that
# defeats `set -e`.
#
# For now our workaround is to put `|| return` in the `run_foo` just
# after each nontrivial command that isn't the final command in the
# function.
set -euo pipefail

this_dir=${BASH_SOURCE[0]%/*}

# shellcheck source=tools/lib/git.sh
. "${this_dir}"/lib/git.sh


## CLI PARSING

default_suites=(analyze test build_runner drift)
extra_suites=(
)

usage() {
    cat >&2 <<EOF
usage: tools/check [OPTION]... [SUITE]...

Run our tests.

By default, run only on files changed in this branch
as compared to the upstream \`main\`.

By default, run ${#default_suites[@]} suite(s):
  ${default_suites[*]}
and skip ${#extra_suites[@]} suite(s):
  ${extra_suites[*]}

What tests to run:
  --all-files
              Run on all files, not only changed files.
  --diff COMMIT
              Run only on files that differ from the given commit.
              (E.g., \`--diff @\` for files with uncommitted changes;
              \`--diff @~10\` for files changed in last 10 commits; or see
              \`git help revisions\` for many more ways to name a commit.)
  --all       In the given suites, run on all files. If no list of suites
              was specified, run all suites.

Extra things to do:
  --fix       Fix issues found, where possible.
EOF
    exit 2
}

opt_files=branch
opt_all=
opt_fix=
opt_suites=()
while (( $# )); do
    case "$1" in
        --diff) shift; opt_files=diff:"$1"; shift;;
        --all-files) opt_files=all; shift;;
        --all) opt_files=all; opt_all=1; shift;;
        --fix) opt_fix=1; shift;;
        analyze|test|build_runner|drift)
            opt_suites+=("$1"); shift;;
        *) usage;;
    esac
done

if (( ! "${#opt_suites[@]}" )); then
    if [ -n "${opt_all}" ]; then
        opt_suites=( "${default_suites[@]}" "${extra_suites[@]}" )
    else
        opt_suites=( "${default_suites[@]}" )
    fi
fi

files_base_commit=
# shellcheck disable=SC2119  # this is a silly warning
case "$opt_files" in
    all) ;;
    branch) files_base_commit="$(git_base_commit)";;
    diff:*) files_base_commit="${opt_files#diff:}";;
esac


## EXECUTION

rootdir=$(git rev-parse --show-toplevel)
cd "$rootdir"

# True just if $opt_files intersects the given set of paths.
files_check() {
    case "$opt_files" in
        all)
            ;;
        branch | diff:*)
            ! git diff --quiet "${files_base_commit}" -- "$@"
            ;;
    esac
}

# usage: check_no_changes CHANGE_DESCRIPTION [GIT_PATHSPECS...]
#
# Check that there were no changes to files matching GIT_PATHSPECS.
# With `--fix`, describe the changes but leave them in place;
# otherwise any changes get cleaned up but cause failure.
#
# This is useful for suites that check that some generated files
# in the tree are up to date.  Such a suite might regenerate the
# files, then call `check_no_changes` on the outputs to check that
# they match what was already in the tree.  Typically it also calls
# `check_no_uncommitted_or_untracked` on the same output paths
# before regenerating, to avoid clobbering any existing changes.
#
# A Git pathspec (as in GIT_PATHSPECS) is a filename, directory,
# or other pattern describing a subset of paths in the Git tree or worktree,
# to be passed as positional arguments to `git diff`, `git clean`, and
# many other Git commands.  For docs, see `git help glossary` under "pathspec".
#
# The CHANGE_DESCRIPTION is used in the error message on failure,
# or the informational message when `--fix` is triggered.
check_no_changes() {
    local change_description="$1"; shift

    if git diff --quiet -- "$@" \
            && no_untracked_files "$@"; then
        return
    fi

    if [ -n "${opt_fix}" ]; then
        echo >&2 "There were ${change_description}:"
        git_status_short "$@"
    else
        echo >&2 "Error: there were ${change_description}:"
        git_status_short "$@"
        git checkout HEAD -- "$@"
        git clean -fd --quiet -- "$@"
        return 1
    fi
}

run_analyze() {
    flutter analyze
}

run_test() {
    flutter test
}

run_build_runner() {
    check_no_uncommitted_or_untracked '*.g.dart' \
    || return

    # build_runner has a --verbose, but lacks a --quiet.
    # So we filter out "[INFO]" messages ourselves.
    dart run build_runner build --delete-conflicting-outputs \
    | perl -lne '
        BEGIN { my $silence = 0 }
        if (/^\[INFO\]/) { $silence = 1 }
        elsif (/^\[[A-Z]/) { $silence = 0 }
        print if (!$silence)
      ' \
    || return

    check_no_changes "updates to *.g.dart files" '*.g.dart'
}

run_drift() {
    local schema_dir=test/model/schemas/

    # We omit from this files_check some files that in principle can affect
    # the outcome of this suite, but are expected to more often just cause noise
    # by rerunning it on changes that cannot actually affect it:
    #   pubspec.{yaml,lock} tools/check
    files_check lib/model/database{,.g}.dart "${schema_dir}" \
    || return 0

    check_no_uncommitted_or_untracked "${schema_dir}" \
    || return

    dart run drift_dev schema dump \
        lib/model/database.dart "${schema_dir}" \
    || return
    dart run drift_dev schema generate --data-classes --companions \
        "${schema_dir}" "${schema_dir}" \
    || return

    check_no_changes "schema updates" "${schema_dir}"
}

failed=()
for suite in "${opt_suites[@]}"; do
    echo "Running $suite..."
    case "$suite" in
        analyze)      run_analyze ;;
        test)         run_test ;;
        build_runner) run_build_runner ;;
        drift)        run_drift ;;
        *)            echo >&2 "Internal error: unknown suite $suite" ;;
    esac || failed+=( "$suite" )
done

if (( ${#failed[@]} )); then
    cat >&2 <<EOF

FAILED: ${failed[*]}

To rerun the suites that failed, run:
  $ tools/check ${failed[*]}
EOF
    exit 1
fi

echo "Passed!"
